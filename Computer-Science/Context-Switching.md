---
title: Context Switching
description: 컨텍스트 스위칭 (문맥 교환)
published: true
date: 2025-02-10T00:43:23.422Z
tags: cs
editor: markdown
dateCreated: 2025-02-10T00:43:23.422Z
---

컨텍스트 스위칭은 단순히 프로세스나 스레드 간의 전환을 의미하는 것이 아니라, 운영체제가 멀티태스킹을 지원하기 위해 각 실행 단위의 **상태(context)** 를 정밀하게 관리하는 복잡한 메커니즘이다.

---

## 1.기본 개념

### 1.1. 프로세스와 스레드
- **프로세스**: 독립된 메모리 공간과 자원을 가지며, 서로 격리되어 실행된다. 프로세스 간 전환 시 주소 공간 전환과 같은 비용이 발생한다.
- **스레드**: 한 프로세스 내에서 실행되는 단위로, 같은 주소 공간을 공유한다. 스레드 간 전환은 일반적으로 프로세스 전환보다 비용이 낮지만, 동기화 이슈가 증가할 수 있다.

### 1.2. 구성 요소
컨텍스트는 실행 중인 작업의 현재 상태를 나타낸다.

- **CPU 레지스터 값**: 일반 목적 레지스터, 스택 포인터, 프로그램 카운터(PC) 등
- **프로세서 상태**: 조건 플래그, 인터럽트 플래그 등
- **메모리 관리 정보**: 페이지 테이블, TLB(Translation Lookaside Buffer) 엔트리 등
- **기타 시스템 상태**: 사용자 모드/커널 모드 상태, 특수 레지스터 등

---

## 2. 내부 동작 원리

컨텍스트 스위칭은 여러 단계로 이루어지며, 각 단계에서 운영체제와 하드웨어가 긴밀하게 협력해 동작한다.

### 2.1. 현재 작업 중단
- **인터럽트 및 트랩 발생**: 하드웨어 인터럽트(ex: 타이머 인터럽트)나 소프트웨어 트랩(ex: 시스템 호출)이 발생하면 현재 실행 중인 작업을 중단한다.
- **사용자 모드 → 커널 모드 전환**: 인터럽트가 발생하면 CPU는 자동으로 커널 모드로 전환되어, 운영체제 내부의 스케줄러와 관련된 코드를 실행한다.

### 2.2. 현재 컨텍스트 저장
- **레지스터 값 저장**: CPU는 현재 작업의 레지스터 값을 커널 스택 또는 작업 제어 블록([PCB](https://wiki.pien.kr/ko/Computer-Science/PCB), Task Control Block 등)에 저장한다.
- **메모리 관리 상태 업데이트**: 주소 공간 정보, 페이지 테이블 포인터, TLB 캐시 등이 필요에 따라 저장되거나 무효화된다.

### 2.3. 스케줄러에 의한 작업 선택
- **스케줄링 알고리즘 실행**: 운영체제는 Round-Robin, 우선순위 기반, 멀티레벨 큐 등 다양한 스케줄링 알고리즘을 통해 다음 실행 작업을 선택한다.
- **우선순위와 공정성 고려**: 작업의 우선순위, I/O 대기 여부, CPU 사용 패턴 등을 종합적으로 고려하여 최적의 작업을 결정한다.

### 2.4. 새로운 컨텍스트의 복원
- **레지스터 복원**: 선택된 작업의 저장된 레지스터 값과 상태 정보가 복원된다.
- **메모리 및 캐시 재구성**: 필요에 따라 TLB와 캐시가 업데이트되어, 새 작업의 주소 공간과 데이터가 효율적으로 접근될 수 있도록 한다.
- **커널 모드 → 사용자 모드 전환**: 복원 후 CPU는 다시 사용자 모드로 전환되고, 해당 작업은 중단된 시점부터 실행을 재개한다.

---

## 3. 성능 관점

컨텍스트 스위칭은 멀티 태스킹 환경에서 필수적인 메커니즘이지만, 빈번한 스위칭은 여러 성능 저하를 초래한다.

### 3.1. CPU 오버헤드
- **저장/복원 작업**: 매번 레지스터 값을 저장하고 복원하는 데 소모되는 CPU 사이클이 누적되어 오버헤드가 발생한다.
- **파이프라인 플러시**: 파이프라인에 이미 로드된 명령어들이 모두 무효화되어, 재로드하는 과정에서 추가적인 비용이 발생한다.

### 3.2. 캐시와 TLB 미스
- **캐시 오염(Cache Pollution)**: 서로 다른 작업의 데이터와 명령어가 서로 다른 캐시 라인을 차지할 경우, 전환 후 캐시 미스율이 증가하여 성능 저하가 발생한다.
- **TLB 플러시와 재로드**: 프로세스 전환 시 TLB 항목이 무효화되거나 재로딩되어, 메모리 접근 속도에 영향을 줄 수 있다.

### 3.3. 메모리 관리 비용
- **주소 공간 분리 비용**: 프로세스 간의 메모리 보호를 위해 주소 공간이 완전히 분리되어 있으면, 스위칭 시 추가적인 페이지 테이블 업데이트와 관련 오버헤드가 발생할 수 있다.

---

## 4. 스케줄링 정책과 최적화 전략

효율적인 컨텍스트 스위칭 관리는 운영체제의 스케줄링 정책과 직접적으로 연관된다.

### 4.1. 스케줄링 알고리즘의 영향
- **라운드-로빈 스케줄링**: 각 작업에 균등하게 시간을 분배하여 공정성을 보장하지만, 너무 짧은 단위의 작업 분리는 잦은 스위칭으로 인한 오버헤드를 가져올 수 있다.
- **우선순위 기반 스케줄링**: 높은 우선순위의 작업에 더 많은 시간을 할당하지만, 우선순위 역전(priority inversion)과 같은 문제가 발생할 수 있다.
- **멀티레벨 큐 및 다단계 피드백 큐**: 작업의 특성에 따라 다른 큐를 사용해 I/O 바운드와 CPU 바운드 작업을 분리하면, 스위칭 빈도를 최적화할 수 있다.

### 4.2. 최적화 방안
- **스레드/프로세스 수 관리**: 불필요한 스레드나 프로세스 생성을 제한하여, 과도한 스위칭을 방지
- **효율적 동기화 기법 사용**: 락 경합을 줄이기 위한 기법(예: 스핀락, 읽기-쓰기 락)을 적용해, 불필요한 스위칭을 최소화
- **비동기 및 이벤트 기반 설계**: 가능하면 비동기 프로그래밍 모델을 활용하여, 스레드 전환에 따른 비용 감소
- **캐시 친화적 설계**: 데이터 지역성을 강화해, 컨텍스트 전환 후에도 캐시 히트율을 높이는 전략을 고려

