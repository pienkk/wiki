<!--
title: Untitled Page
description: 
published: true
date: 2025-01-02T08:27:54.358Z
tags: 
editor: ckeditor
dateCreated: 2025-01-02T08:27:54.358Z
-->

<ul>
  <li>기본 개념<ul>
      <li>각 Node가 다음 Node만을 가리키는 단방향 연결 구조</li>
      <li>구성 요소<ul>
          <li>head: 리스트의 시작 노드</li>
          <li>tail: 리스트의 마지막 노드</li>
          <li>length: 리스트의 길이</li>
        </ul>
      </li>
      <li>특징<ul>
          <li>순차적 접근만 가능 (이전 노드로 돌아갈 수 없음)</li>
          <li>삽입/삭제가 배열보다 효율적</li>
          <li>랜덤 접근 불가 (인덱스로 직접 접근 불가)</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>주요 메서드<ul>
      <li>데이터 추가<ul>
          <li>push: 리스트 끝에 노드 추가</li>
          <li>unshift: 리스트 앞에 노드 추가</li>
          <li>insert: 특정 위치에 노드 추가</li>
        </ul>
      </li>
      <li>데이터 삭제<ul>
          <li>pop: 마지막 노드 삭제</li>
          <li>shift: 첫 번째 노드 삭제</li>
          <li>remove: 특정 위치 노드 삭제</li>
        </ul>
      </li>
      <li>데이터 접근/수정<ul>
          <li>get: 특정 위치의 노드 조회</li>
          <li>set: 특정 위치의 노드 값 수정</li>
        </ul>
      </li>
      <li>기타<ul>
          <li>reverse: 리스트 순서 뒤집기</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>시간 복잡도<ul>
      <li>삽입/삭제<ul>
          <li>처음: O(1)</li>
          <li>중간/끝: O(n)</li>
        </ul>
      </li>
      <li>탐색: O(n)</li>
      <li>접근: O(n)</li>
    </ul>
  </li>
  <li>장단점<ul>
      <li>장점<ul>
          <li>동적 크기 조절 가능</li>
          <li>삽입/삭제 효율적 (포인터만 변경하면 됨)</li>
          <li>필요한 만큼만 메모리 할당 (배열처럼 미리 큰 공간 필요 없음)</li>
        </ul>
      </li>
      <li>단점<ul>
          <li>랜덤 접근 불가</li>
          <li>이전 노드로 이동 불가</li>
          <li>각 노드마다 다음 노드 주소를 저장하는 추가 메모리 필요</li>
        </ul>
      </li>
    </ul>
  </li>
  <li>Node<ul>
      <li> &nbsp;class Node {
        &nbsp; &nbsp; &nbsp;constructor(value) {
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.value = value
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.next = null
        &nbsp; &nbsp; &nbsp;}
        &nbsp;}
      </li>
    </ul>
  </li>
  <li>Single Linked List<ul>
      <li> &nbsp;class SingleLinkedList {
        &nbsp; &nbsp; &nbsp;constructor() {
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.head = null
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.tail = null
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.length = 0;
        &nbsp; &nbsp; &nbsp;}
        &nbsp;}
      </li>
      <li>싱글 링크드 리스트에서 특정 작업을 하기 위해선 직접 메서드를 구현해서 사용해야 한다.</li>
      <li>아래에 서술할 메서드들은 모두 <code>SingleLinkedList</code> 클래스 내부에 구현된다.</li>
      <li>push<ul>
          <li>리스트 마지막 위치에 <code>Node</code> 를 추가하고 리스트를 반환하는 메서드</li>
          <li>신규 <code>Node</code> 생성</li>
          <li>기존 tail의 next에 신규 <code>Node</code> 할당</li>
          <li>tail을 신규 <code>Node</code>에 할당</li>
          <li>리스트가 비어있을 경우 생성한 <code>Node</code>를 head와 tail에 할당</li>
          <li> &nbsp; push (value) {
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const node = new Node(value)
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;// 링크드 리스트가 비어있을 경우
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(!this.head) {
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.head = node
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.tail = this.head
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} else {
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.tail.next = node
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.tail = node
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.length++
            &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return this
            &nbsp; &nbsp; &nbsp;}
          </li>
        </ul>
      </li>
      <li>pop<ul>
          <li>리스트 마지막 위치의 <code>Node</code>를 삭제하고, 삭제한 <code>Node</code>를 반환하는 메서드</li>
          <li>this.tail의 이전 <code>Node</code>를 this.head부터 탐색 후 변수 생성</li>
          <li>this.tail의 이전 <code>Node</code>를 this.tail로 수정</li>
          <li>this.tail의 next를 null로 지정</li>
          <li>length가 0일 경우 this.head, this.tail을 null로 지정</li>
        </ul>
      </li>
    </ul>
  </li>
  <li> &nbsp; &nbsp; &nbsp;pop () {
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;let preNode = this.head
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;let currentNode = this.head
    &nbsp;
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (this.head === null) return undefined
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;while (currentNode.next) {
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;preNode = currentNode
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;currentNode = currentNode.next
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}
    &nbsp;
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.tail = preNode
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.tail.next = null
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.length--
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (this.length === 0) {
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.head = null
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.tail = null
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return currentNode
    &nbsp; &nbsp;&nbsp;</li>
</ul>
<p>&nbsp;</p>
<pre><code class="language-plaintext">pop () {
		          let preNode = this.head
		          let currentNode = this.head
		  
		          if (this.head === null) return undefined
		          while (currentNode.next) {
		              preNode = currentNode
		              currentNode = currentNode.next
		          }
		  
		          this.tail = preNode
		          this.tail.next = null
		          this.length--
		          if (this.length === 0) {
		              this.head = null
		              this.tail = null
		          }
		          return currentNode
		     </code></pre>
<ul>
  <li>
  </li>
  <li>shift<ul>
      <li>리스트 첫번째 위치의 <code>Node</code>를 제거하고, 제거한 <code>Node</code>를 반환하는 메서드</li>
      <li>head를 반환할 수 있도록 변수에 지정</li>
      <li>head의 next를 head로 지정</li>
      <li>length가 0일 경우 head와 tail을 null로 지정</li>
      <li> &nbsp; &nbsp; &nbsp;shift () {
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (this.head === null) return undefined
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const head = this.head
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.head = head.next
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.length--
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (this.length === 0) {
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.head = null
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.tail = null
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return head
        &nbsp; &nbsp; &nbsp;}
      </li>
    </ul>
  </li>
  <li>unshift<ul>
      <li>리스트 첫번째 위치에 <code>Node</code>를 추가하고, 리스트를 반환하는 메서드</li>
      <li>신규 <code>Node</code> 생성</li>
      <li>기존 head를 생성한 <code>Node</code>의 next로 할당</li>
      <li>head를 생성한 <code>Node</code> 로 변경</li>
      <li>기존 리스트가 비어있을 경우, tail을 head와 동일하게 변경</li>
      <li> &nbsp; &nbsp; &nbsp;unshift (value) {
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const node = new Node(value)
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (this.head === null) {
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.head = node
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.tail = node
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;} else {
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;node.next = this.head
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.head = node
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.length++
        &nbsp;
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return this
        &nbsp; &nbsp; &nbsp;}
      </li>
    </ul>
  </li>
  <li>get<ul>
      <li>특정 인덱스의 <code>Node</code>를 탐색해 반환하는 메서드</li>
      <li>음수 혹은 length 이상인 값은 null 반환</li>
      <li>반복문을 통해 해당 인덱스의 <code>Node</code> 탐색 후 반환</li>
      <li> &nbsp; &nbsp; &nbsp;get (index) {
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;let currentNode = this.head
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if(index &lt; 0 || index &gt;= this.length) return null
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (let i = 0; i &lt; index; i++) {
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;currentNode = currentNode.next
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}
        &nbsp;
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return currentNode
        &nbsp; &nbsp; &nbsp;}
      </li>
    </ul>
  </li>
  <li>set<ul>
      <li>특정 인덱스의 <code>Node</code> 값을 변경하는 메서드</li>
      <li><code>get</code> 메서드로 특정 인덱스의 <code>Node</code>를 탐색</li>
      <li>탐색한 <code>Node</code> 값 변경</li>
      <li> &nbsp; set (index, value) {
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const getNode = this.get(index)
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (getNode) {
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;getNode.value = value
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return true
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return false
        &nbsp; &nbsp; &nbsp;}
      </li>
    </ul>
  </li>
  <li>insert<ul>
      <li>특정 인덱스에 <code>Node</code>를 추가해 성공 여부를 true, false로 반환하는 메서드<ul>
          <li>추가된 인덱스 이후의 <code>Node</code>의 인덱스는 1씩 추가된다.</li>
        </ul>
      </li>
      <li><code>get</code> 메서드로 특정 인덱스 - 1와 특정 인덱스의 <code>Node</code>를 탐색</li>
      <li>생성한 <code>Node</code>의 next를 특정 인덱스로 수정</li>
      <li>특정 인덱스 -1 의 next는 생성한 <code>Node</code>로 수정</li>
      <li>특정 인덱스가 0이거나, length와 동일한 경우 <code>unshift</code> 혹은 <code>push</code>를 사용</li>
      <li> &nbsp; insert (index, value) {
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (index &lt; 0 || index &gt; this.length) return false
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (index === 0) return !!this.unshift(value)
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (index === this.length) return !!this.push(value)
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const preNode = this.get(index - 1)
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const newNode = new Node(value)
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;newNode.next = preNode.next
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;preNode.next = newNode
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.length++
        &nbsp; &nbsp; &nbsp;
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return true
        &nbsp; &nbsp; &nbsp;}
      </li>
    </ul>
  </li>
  <li>remove<ul>
      <li>특정 인덱스의 <code>Node</code>를 삭제해 삭제한 <code>Node</code>를 반환하는 메서드</li>
      <li><code>get</code> 메서드로 특정 인덱스 - 1 탐색</li>
      <li>특정 인덱스 <code>Node</code> 변수 지정</li>
      <li>특정 인덱스 -1 의 <code>Node</code>의 next를 특정 인덱스 + 1 로 지정</li>
      <li>특정 인덱스가 0이거나, length - 1 과 동일한 경우 <code>shift</code> 혹은 <code>pop</code>을 사용</li>
      <li> &nbsp; &nbsp; &nbsp;remove (index) {
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (index &lt; 0 || index &gt;= this.length) return undefined
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (index === 0) return this.shift()
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (index === this.length - 1) return this.pop()
        &nbsp;
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const preNode = this.get(index - 1)
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const removeNode = preNode.next
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;preNode.next = removeNode.next
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.length--
        &nbsp;
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return removeNode
        &nbsp; &nbsp; &nbsp;}
      </li>
    </ul>
  </li>
  <li>reverse<ul>
      <li>리스트의 값을 반대로 정렬해 리스트를 반환하는 메서드</li>
      <li>현재의 head와 tail을 서로 변경</li>
      <li>tail로 부터 시작해 next를 이전 <code>Node</code>로 할당</li>
      <li> &nbsp; &nbsp; &nbsp;reverse () {
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;if (this.length &lt;= 0) return false
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;let currentNode = this.head
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.head = this.tail
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.tail = currentNode
        &nbsp;
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;let prevNode = null
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;for (let i = 0; i &lt; this.length; i++){
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;const nextNode = currentNode.next
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;currentNode.next = prevNode
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;prevNode = currentNode
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;currentNode = nextNode
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;}
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;this.tail.next = null
        &nbsp;
        &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;return this
        &nbsp; &nbsp; &nbsp;}
        &nbsp;}
      </li>
    </ul>
  </li>
</ul>
